
# Dev

## Архитектура

Основные классы:

* [Factory](./src/models.ts) - Фабрика типов.
* [Config](./src/config.ts) - Базовые настройки для всех создаваемых типов.
* [Settings](./src/settings.ts) - Локальные настройки типа.
* [Metadata](./src/metadata.ts) - Контейнер хранения информации о типе.
* [*Model](./src/models.ts) - Обертки над типами с привязкой к свойствам объектов `{config, meta, settings, key}`.
* [Context](./src/context.ts) - Временный класс для отслеживания параметров текущей ветки(свойства объекта) при валидации значений, а также регистрации ошибок.

### Устройство *Model

Классы моделей `*Model` представляют из себя легкие обертки, имеющие только ссылки на `Config/Metadata/Settings` и привязку к имени свойства объекта `key`(если она есть). Изменение любой настройки(`Metadata/Settings`) не меняет инстанс, а лишь вызывает копирование измененного параметра и оборачивание в новый экземпляр.

В этом примере все три внутренних свойства ссылаются на одни параметры типа(за исключением `box`), но обертки привязаны к разным ключам:

```ts
const numModel = v.num() // NumModel.key === null
const objModel({
  foo: numModel, // key === 'foo'
  bar: numModel  // key === 'foo'
  box: numModel.stopError()  // key === 'box' and Settings.copy({stopIfError: true})
})
```

Структура корневой модели, например Plain-объекта, подобна вложенным массивам и соответствует первоначальному определению модели:

```
ObjModel: [
  NumModel:'foo',
  NumModel:'bar',
  NumModel:'box'
]
```

### Обход дерева моделей

Проверка входного типа начинается с обхода дерева моделей и передает текущую ветку(свойство объекта) ожидаемой модели. Модель проверяет соответствие значения ожидаемому типу(используя `Metadata` как контейнер для хранения информации о типе) и возвращает соответствующий результат `{ok, value}`. 

```ts
// StrModel
if(!isString(value)){
  return ctx.throwFaultyValueError(value, 'Ожидался type string.') // {ok: false, ...}
}
return { ok: true, value }
```

Модели всегда возвращают `{ok: true, ...}` или вызывают функции контекста. Роль `Context`: определить текущие параметры ветки и вернуть ожидаемый результат при ошибке(например `null` при `stopError()`) или поднять исключение. Если контекст возвращает `{ok: false}`, модель прерывает валидацию и поднимает ошибку выше по дереву. `Context` регистрирует ошибки и предупреждения, которые можно получить по окончании валидации типа.

### Расширение типов и ограничения

Как видно из описания выше: модели, привязываясь к свойствам или изменяя параметры, копируют ссылки на внутренние параметры(`Config/Metadata/Settings`) и вызывают конструкторы со строго определенным списком параметров `constructor(config, meta, settings, key)`. Из чего следует: расширяемые классы не могут иметь собственных конструкторов и свойств.

Добавление пользовательского типа к API предполагает:

* Расширение базового класса `Model/BaseModel/BaseRangeModel`, чаще всего это `BaseModel`, и реализация единственного метода `protected _validate(ctx, value)`.
* Добавление функции к фабрике моделей `RootFactory.myType(): MyType`.

Расширяемые классы, для хранения параметров типа, должны использовать базовые подтипы `Metadata`. Базовые подтипы `Metadata` покрывают все варианты хранения информации о Json-типе: литералы, min/max для чисел, список регулярных выражений для строк или список дочерних моделей.

Если типу не нужны данные для хранения, можно и вовсе не использовать `Metadata` и выбрать просто подходящий подтип. Например мы можем использовать `RegExp` не прибегая к кешу фабрики `RootFactory._regExpCache`:

```ts
// Здесь мы укажем дженерик подтипа string
class StrNumberModel extends BaseModel<string> {
  protected override _validate (ctx: Context, value: any): TRes<string> {
    if (isString(value) && /^[0-9]+$/.test(value)) {
      return {ok: true, value}
    }
    return ctx.throwFaultyValueError(value, 'Invalid number format')
  }
}
```

Тогда стандартная реализация фабричной функции может быть очень простой:

```ts
import { RootFactory as _RootFactory, Factory as _Factory } from 'jnv'

class RootFactory extends _RootFactory {
  strNumber (): StrNumberModel {
    // Стандартный конструктор должен получить:
    // + ссылку на общую конфигурацию
    // + метаданные типа, это для реализованного типа StrNumberModel,
    //   но в примере мы его не используем
    // + настройки по умолчанию
    // + ключ(имя свойства) будет привязан автоматически и здесь он остается null
    return new StrNumberModel(this._config, Metadata.str(), this._defaultSettings, null)
  }
}
```

Здесь не приводится пример реализации `Factory` для обновленного `RootFactory`, но пример можно увидеть в [index.test.ts](./src/index.test.ts) - все сводится к банальному копированию класса и замене `RootFactory` на пользовательский.

> Несмотря на то что `jnv` предназначен для валидации `JsonLike` типов, модели могут возвратить любой тип и даже класс. Результат после валидации применяется к свойству и не модифицируется.

Если модель должна хранить метаданные, не предусмотренные стандартными подтипами `Metadata`, можно расширить свой класс. Основная задача правильно реализовать функцию `Metadata.copy()`.

```ts
class MyMetadata<T> extends Metadata<T> {
  myPropertyForMyType: T

  override copy(): Metadata<T> {
    const meta = new Metadata<any>(this._type)
    // копируем стандартное тело этого метода
    // ...
    // и добавляем копирование собственного свойства
    meta.myPropertyForMyType = copyMyProperty(this.myPropertyForMyType)
  }
}
```

Остается применить этот класс в функции фабрики и, если нужно, передать аргументы:

```ts
class RootFactory extends _RootFactory {
  strNumber (args: any): StrNumberModel {
    return new StrNumberModel(this._config, new MyMetadata(args), this._defaultSettings, null)
  }
}
```

## Использование проекта с *.ts фалами без предварительной компиляции

Сырой проект может использоваться как локальная зависимость для `Vite/Vue` или бандлеров разрешающих пути `.ts` файлов из `package.json` и позволяющих использовать TS-типы.

Локальная зависимость устанавливается как и обычный пакет `npm`:

    npm i C:/.../jnv
